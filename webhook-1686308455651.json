{"status":"Failed","policy":{"name":"Webhooks","description":""},"findingKey":"4qILotmQA+5PO8j6M5kVjw","findingId":"4qILotmQA+5PO8j6M5kVjw","cloudGuardAccountId":"51722","origin":"Compliance Engine","bundle":{"name":"CIS Kubernetes Benchmark v1.6.1","description":"Automated Validation of Kubernetes CIS Benchmark v1.6.1 Prescriptive guidance for establishing a secure configuration posture for Kubernetes 1.6.1\nFor additional reference: https://www.cisecurity.org/benchmark/kubernetes/","id":-70},"reportTime":"2023-06-09T11:00:31.243Z","rule":{"name":"Apply Security Context to Your Pods and Containers","ruleId":"D9.K8S.OPE.06","description":"Apply Security Context to Your Pods and Containers. A security context defines the operating system security settings (uid, gid, capabilities, SELinux role, etc..) applied to a container. When designing your containers and pods, make sure that you configure the security context for your pods, containers, and volumes. A security context is a property defined in the deployment yaml. It controls the security parameters that will be assigned to the pod/container/volume.","remediation":"Follow the Kubernetes documentation and apply security contexts to your pods. For a suggested list of security contexts, you may refer to the CIS Security Benchmark for Docker Containers.\n**References**\nhttps://kubernetes.io/docs/concepts/policy/security-context/","complianceTags":"5.6.3","logicHash":"IESpWUCb45AmMIPF+zZBxA","severity":"Low"},"account":{"id":"5af13ab5-72ed-43b6-9544-33c9236d62f0","name":"nu-openshift-cluster","vendor":"Kubernetes","dome9CloudAccountId":"5af13ab5-72ed-43b6-9544-33c9236d62f0","organizationalUnitId":"00000000-0000-0000-0000-000000000000","organizationalUnitPath":""},"region":"Global","entity":{"spec":{"affinity":{"nodeAffinity":{"preferredDuringSchedulingIgnoredDuringExecution":null,"requiredDuringSchedulingIgnoredDuringExecution":{"nodeSelectorTerms":[{"matchExpressions":null,"matchFields":[{"key":"metadata.name","operator":"In","values":["worker-2.demoenv.local"]}]}]}},"podAffinity":null,"podAntiAffinity":null},"containers":[{"args":null,"command":["/bin/bash","-c","#!/bin/bash\nset -euo pipefail\n\n# if another process is listening on the cni-server socket, wait until it exits\ntrap 'kill $(jobs -p); rm -f /etc/cni/net.d/80-openshift-network.conf ; exit 0' TERM\nretries=0\nwhile true; do\n  if echo 'test' | socat - UNIX-CONNECT:/var/run/openshift-sdn/cniserver/socket &>/dev/null; then\n    echo \"warning: Another process is currently listening on the CNI socket, waiting 15s ...\" 2>&1\n    sleep 15 & wait\n    (( retries += 1 ))\n  else\n    break\n  fi\n  if [[ \"${retries}\" -gt 40 ]]; then\n    echo \"error: Another process is currently listening on the CNI socket, exiting\" 2>&1\n    exit 1\n  fi\ndone\n\n# local environment overrides\nif [[ -f /etc/sysconfig/openshift-sdn ]]; then\n  set -o allexport\n  source /etc/sysconfig/openshift-sdn\n  set +o allexport\nfi\n#BUG: cdc accidentally mounted /etc/sysconfig/openshift-sdn as DirectoryOrCreate; clean it up so we can ultimately mount /etc/sysconfig/openshift-sdn as FileOrCreate\n# Once this is released, then we can mount it properly\nif [[ -d /etc/sysconfig/openshift-sdn ]]; then\n  rmdir /etc/sysconfig/openshift-sdn || true\nfi\n\n# configmap-based overrides\nif [[ -f /env/${K8S_NODE_NAME} ]]; then\n  set -o allexport\n  source /env/${K8S_NODE_NAME}\n  set +o allexport\nfi\n\n# Take over network functions on the node\nrm -f /etc/cni/net.d/80-openshift-network.conf\ncp -f /opt/cni/bin/openshift-sdn /host-cni-bin/\n\nmtu_override_flag=\nif [[ -f /config-mtu-migration/mtu.yaml ]]; then\n  mtu_override_flag=\"--mtu-override /config-mtu-migration/mtu.yaml\"\nfi\n\n# Launch the network process\nexec /usr/bin/openshift-sdn-node \\\n  --node-name ${K8S_NODE_NAME} --node-ip ${K8S_NODE_IP} \\\n  --platform-type BareMetal \\\n  --proxy-config /config/kube-proxy-config.yaml \\\n  ${mtu_override_flag} \\\n  --v ${OPENSHIFT_SDN_LOG_LEVEL:-2}\n"],"env":[{"name":"KUBERNETES_SERVICE_PORT","value":"6443","valueFrom":null},{"name":"KUBERNETES_SERVICE_HOST","value":"api-int.openshift-csa.demoenv.local","valueFrom":null},{"name":"OPENSHIFT_DNS_DOMAIN","value":"cluster.local","valueFrom":null},{"name":"K8S_NODE_NAME","value":null,"valueFrom":{"secretKeyRef":null}},{"name":"K8S_NODE_IP","value":null,"valueFrom":{"secretKeyRef":null}}],"image":"quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:d4f3f0f4d806c905b54760745793d79ffc737198bf05cabaf0a0fd6a6188441d","livenessProbe":null,"name":"sdn","imageDetails":{"registry":"quay.io/openshift-release-dev","repository":"ocp-v4.0-art-dev","tag":"sha256:d4f3f0f4d806c905b54760745793d79ffc737198bf05cabaf0a0fd6a6188441d"},"parsedArgs":[{"key":"c","value":"#!/bin/bashset"},{"key":"euo","value":"pipefail# if another process is listening on the cni-server socket, wait until it exitstrap 'kill $(jobs"},{"key":"p);","value":"rm"},{"key":"f","value":"/etc/cni/net.d/80-openshift-network.conf ; exit 0' TERMretries=0while true; do  if echo 'test' | socat"},{"key":"","value":"UNIX-CONNECT:/var/run/openshift-sdn/cniserver/socket &>/dev/null; then    echo \"warning: Another process is currently listening on the CNI socket, waiting 15s ...\" 2>&1    sleep 15 & wait    (( retries += 1 ))  else    break  fi  if [[ \"${retries}\""},{"key":"gt","value":"40 ]]; then    echo \"error: Another process is currently listening on the CNI socket, exiting\" 2>&1    exit 1  fidone# local environment overridesif [["},{"key":"f","value":"/etc/sysconfig/openshift-sdn ]]; then  set"},{"key":"o","value":"allexport  source /etc/sysconfig/openshift-sdn  set +o allexportfi#BUG: cdc accidentally mounted /etc/sysconfig/openshift-sdn as DirectoryOrCreate; clean it up so we can ultimately mount /etc/sysconfig/openshift-sdn as FileOrCreate# Once this is released, then we can mount it properlyif [["},{"key":"d","value":"/etc/sysconfig/openshift-sdn ]]; then  rmdir /etc/sysconfig/openshift-sdn || truefi# configmap-based overridesif [["},{"key":"f","value":"/env/${K8S_NODE_NAME} ]]; then  set"},{"key":"o","value":"allexport  source /env/${K8S_NODE_NAME}  set +o allexportfi# Take over network functions on the noderm"},{"key":"f","value":"/etc/cni/net.d/80-openshift-network.confcp"},{"key":"f","value":"/opt/cni/bin/openshift-sdn /host-cni-bin/mtu_override_flag=if [["},{"key":"f","value":"/config-mtu-migration/mtu.yaml ]]; then  mtu_override_flag=\"--mtu-override /config-mtu-migration/mtu.yaml\"fi# Launch the network processexec /usr/bin/openshift-sdn-node \\ "},{"key":"node-name","value":"${K8S_NODE_NAME}"},{"key":"node-ip","value":"${K8S_NODE_IP} \\ "},{"key":"platform-type","value":"BareMetal \\ "},{"key":"proxy-config","value":"/config/kube-proxy-config.yaml \\  ${mtu_override_flag} \\ "},{"key":"v","value":"${OPENSHIFT_SDN_LOG_LEVEL:-2}"}],"ports":[{"containerPort":10256,"hostIP":null,"hostPort":10256,"name":"healthz","protocol":"TCP"}],"readinessProbe":{"exec":{"command":["test","-f","/etc/cni/net.d/80-openshift-network.conf"]},"failureThreshold":3,"httpGet":null,"initialDelaySeconds":5,"periodSeconds":5,"successThreshold":1,"tcpSocket":null,"timeoutSeconds":1},"resources":{"limits":null,"requests":{"memory":"200Mi","cpu":"100m"}},"securityContext":{"allowPrivilegeEscalation":null,"capabilities":null,"privileged":true,"procMount":null,"readOnlyRootFilesystem":null,"runAsGroup":null,"runAsNonRoot":null,"runAsUser":null,"seLinuxOptions":null,"windowsOptions":null,"seccompProfile":null},"volumeMounts":[{"name":"config","mountPath":"/config","readOnly":true,"mountPropagation":null,"subPath":null,"subPathExpr":null},{"name":"config-mtu-migration","mountPath":"/config-mtu-migration","readOnly":true,"mountPropagation":null,"subPath":null,"subPathExpr":null},{"name":"env-overrides","mountPath":"/env","readOnly":false,"mountPropagation":null,"subPath":null,"subPathExpr":null},{"name":"host-var-run-crio","mountPath":"/var/run/crio","readOnly":false,"mountPropagation":null,"subPath":null,"subPathExpr":null},{"name":"host-var-run-dbus","mountPath":"/var/run/dbus/","readOnly":true,"mountPropagation":null,"subPath":null,"subPathExpr":null},{"name":"host-var-run-ovs","mountPath":"/var/run/openvswitch/","readOnly":true,"mountPropagation":null,"subPath":null,"subPathExpr":null},{"name":"host-var-run-kubernetes","mountPath":"/var/run/kubernetes/","readOnly":true,"mountPropagation":null,"subPath":null,"subPathExpr":null},{"name":"host-run-netns","mountPath":"/run/netns","readOnly":true,"mountPropagation":"HostToContainer","subPath":null,"subPathExpr":null},{"name":"host-var-run-openshift-sdn","mountPath":"/var/run/openshift-sdn","readOnly":false,"mountPropagation":null,"subPath":null,"subPathExpr":null},{"name":"host-slash","mountPath":"/host","readOnly":true,"mountPropagation":"HostToContainer","subPath":null,"subPathExpr":null},{"name":"host-cni-bin","mountPath":"/host-cni-bin","readOnly":false,"mountPropagation":null,"subPath":null,"subPathExpr":null},{"name":"host-cni-conf","mountPath":"/etc/cni/net.d","readOnly":false,"mountPropagation":null,"subPath":null,"subPathExpr":null},{"name":"host-var-lib-cni-networks-openshift-sdn","mountPath":"/var/lib/cni/networks/openshift-sdn","readOnly":false,"mountPropagation":null,"subPath":null,"subPathExpr":null},{"name":"host-modules","mountPath":"/lib/modules","readOnly":true,"mountPropagation":null,"subPath":null,"subPathExpr":null},{"name":"etc-sysconfig","mountPath":"/etc/sysconfig","readOnly":true,"mountPropagation":null,"subPath":null,"subPathExpr":null},{"name":"kube-api-access-xvbxg","mountPath":"/var/run/secrets/kubernetes.io/serviceaccount","readOnly":true,"mountPropagation":null,"subPath":null,"subPathExpr":null}]},{"args":null,"command":["/bin/bash","-c","#!/bin/bash\nset -euo pipefail\nTLS_PK=/etc/pki/tls/metrics-certs/tls.key\nTLS_CERT=/etc/pki/tls/metrics-certs/tls.crt\n\n# As the secret mount is optional we must wait for the files to be present.\n# The service is created in monitor.yaml and this is created in sdn.yaml.\n# If it isn't created there is probably an issue so we want to crashloop.\nTS=$(date +%s)\nWARN_TS=$(( ${TS} + $(( 20 * 60)) ))\nHAS_LOGGED_INFO=0\n\nlog_missing_certs(){\n    CUR_TS=$(date +%s)\n    if [[ \"${CUR_TS}\" -gt \"WARN_TS\"  ]]; then\n      echo $(date -Iseconds) WARN: sdn-metrics-certs not mounted after 20 minutes.\n    elif [[ \"${HAS_LOGGED_INFO}\" -eq 0 ]] ; then\n      echo $(date -Iseconds) INFO: sdn-metrics-certs not mounted. Waiting 20 minutes.\n      HAS_LOGGED_INFO=1\n    fi\n}\n\nwhile [[ ! -f \"${TLS_PK}\" ||  ! -f \"${TLS_CERT}\" ]] ; do\n  log_missing_certs\n  sleep 5\ndone\n\necho $(date -Iseconds) INFO: sdn-metrics-certs mounted, starting kube-rbac-proxy\nexec /usr/bin/kube-rbac-proxy \\\n  --logtostderr \\\n  --secure-listen-address=:9101 \\\n  --tls-cipher-suites=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 \\\n  --upstream=http://127.0.0.1:29101/ \\\n  --tls-private-key-file=${TLS_PK} \\\n  --tls-cert-file=${TLS_CERT}\n"],"env":null,"image":"quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:9d9c95c485abf0c842ec6f7b0c82e05176b3f8351fe840ae5ffa4d91f0100fb7","livenessProbe":null,"name":"kube-rbac-proxy","imageDetails":{"registry":"quay.io/openshift-release-dev","repository":"ocp-v4.0-art-dev","tag":"sha256:9d9c95c485abf0c842ec6f7b0c82e05176b3f8351fe840ae5ffa4d91f0100fb7"},"parsedArgs":[{"key":"c","value":"#!/bin/bashset"},{"key":"euo","value":"pipefailTLS_PK=/etc/pki/tls/metrics-certs/tls.keyTLS_CERT=/etc/pki/tls/metrics-certs/tls.crt# As the secret mount is optional we must wait for the files to be present.# The service is created in monitor.yaml and this is created in sdn.yaml.# If it isn't created there is probably an issue so we want to crashloop.TS=$(date +%s)WARN_TS=$(( ${TS} + $(( 20 * 60)) ))HAS_LOGGED_INFO=0log_missing_certs(){    CUR_TS=$(date +%s)    if [[ \"${CUR_TS}\""},{"key":"gt","value":"\"WARN_TS\"  ]]; then      echo $(date"},{"key":"Iseconds)","value":"WARN: sdn-metrics-certs not mounted after 20 minutes.    elif [[ \"${HAS_LOGGED_INFO}\""},{"key":"eq","value":"0 ]] ; then      echo $(date"},{"key":"Iseconds)","value":"INFO: sdn-metrics-certs not mounted. Waiting 20 minutes.      HAS_LOGGED_INFO=1    fi}while [[ !"},{"key":"f","value":"\"${TLS_PK}\" ||  !"},{"key":"f","value":"\"${TLS_CERT}\" ]] ; do  log_missing_certs  sleep 5doneecho $(date"},{"key":"Iseconds)","value":"INFO: sdn-metrics-certs mounted, starting kube-rbac-proxyexec /usr/bin/kube-rbac-proxy \\ "},{"key":"logtostderr","value":"\\ "},{"key":"secure-listen-address","value":":9101 \\ "},{"key":"tls-cipher-suites","value":"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 \\ "},{"key":"upstream","value":"http://127.0.0.1:29101/ \\ "},{"key":"tls-private-key-file","value":"${TLS_PK} \\ "},{"key":"tls-cert-file","value":"${TLS_CERT}"}],"ports":[{"containerPort":9101,"hostIP":null,"hostPort":9101,"name":"https","protocol":"TCP"}],"readinessProbe":null,"resources":{"limits":null,"requests":{"memory":"20Mi","cpu":"10m"}},"securityContext":null,"volumeMounts":[{"name":"sdn-metrics-certs","mountPath":"/etc/pki/tls/metrics-certs","readOnly":true,"mountPropagation":null,"subPath":null,"subPathExpr":null},{"name":"kube-api-access-xvbxg","mountPath":"/var/run/secrets/kubernetes.io/serviceaccount","readOnly":true,"mountPropagation":null,"subPath":null,"subPathExpr":null}]}],"dnsConfig":null,"hostAliases":null,"hostIPC":false,"hostNetwork":true,"hostPID":true,"initContainers":null,"nodeInfo":{"conditions":[{"message":"kubelet has sufficient memory available","reason":"KubeletHasSufficientMemory","status":"False","type":"MemoryPressure"},{"message":"kubelet has no disk pressure","reason":"KubeletHasNoDiskPressure","status":"False","type":"DiskPressure"},{"message":"kubelet has sufficient PID available","reason":"KubeletHasSufficientPID","status":"False","type":"PIDPressure"},{"message":"kubelet is posting ready status","reason":"KubeletReady","status":"True","type":"Ready"}],"labels":[{"key":"beta.kubernetes.io/arch","value":"amd64"},{"key":"beta.kubernetes.io/os","value":"linux"},{"key":"kubernetes.io/arch","value":"amd64"},{"key":"kubernetes.io/hostname","value":"worker-2.demoenv.local"},{"key":"kubernetes.io/os","value":"linux"},{"key":"node-role.kubernetes.io/worker","value":""},{"key":"node.openshift.io/os_id","value":"rhcos"}]},"nodeName":"worker-2.demoenv.local","priority":2000001000,"priorityClassName":"system-node-critical","securityContext":{"fsGroup":null,"runAsGroup":null,"runAsNonRoot":null,"runAsUser":null,"seLinuxOptions":null,"supplementalGroups":null,"sysctls":null,"windowsOptions":null,"seccompProfile":null},"serviceAccount":"sdn","serviceAccountName":"sdn","tolerations":[{"key":null,"operator":"Exists","effect":null}],"volumes":[{"hostPath":null,"flexVolume":null,"name":"config","persistentVolumeClaim":null},{"hostPath":null,"flexVolume":null,"name":"config-mtu-migration","persistentVolumeClaim":null},{"hostPath":null,"flexVolume":null,"name":"env-overrides","persistentVolumeClaim":null},{"hostPath":{"path":"/etc/sysconfig","type":""},"flexVolume":null,"name":"etc-sysconfig","persistentVolumeClaim":null},{"hostPath":{"path":"/lib/modules","type":""},"flexVolume":null,"name":"host-modules","persistentVolumeClaim":null},{"hostPath":{"path":"/var/run/crio","type":""},"flexVolume":null,"name":"host-var-run-crio","persistentVolumeClaim":null},{"hostPath":{"path":"/run/netns","type":""},"flexVolume":null,"name":"host-run-netns","persistentVolumeClaim":null},{"hostPath":{"path":"/var/run/dbus","type":""},"flexVolume":null,"name":"host-var-run-dbus","persistentVolumeClaim":null},{"hostPath":{"path":"/var/run/openvswitch","type":""},"flexVolume":null,"name":"host-var-run-ovs","persistentVolumeClaim":null},{"hostPath":{"path":"/var/run/kubernetes","type":""},"flexVolume":null,"name":"host-var-run-kubernetes","persistentVolumeClaim":null},{"hostPath":{"path":"/var/run/openshift-sdn","type":""},"flexVolume":null,"name":"host-var-run-openshift-sdn","persistentVolumeClaim":null},{"hostPath":{"path":"/","type":""},"flexVolume":null,"name":"host-slash","persistentVolumeClaim":null},{"hostPath":{"path":"/var/lib/cni/bin","type":""},"flexVolume":null,"name":"host-cni-bin","persistentVolumeClaim":null},{"hostPath":{"path":"/var/run/multus/cni/net.d","type":""},"flexVolume":null,"name":"host-cni-conf","persistentVolumeClaim":null},{"hostPath":{"path":"/var/lib/cni/networks/openshift-sdn","type":""},"flexVolume":null,"name":"host-var-lib-cni-networks-openshift-sdn","persistentVolumeClaim":null},{"hostPath":null,"flexVolume":null,"name":"sdn-metrics-certs","persistentVolumeClaim":null},{"hostPath":null,"flexVolume":null,"name":"kube-api-access-xvbxg","persistentVolumeClaim":null}]},"status":{"phase":"Running","podIP":"192.168.10.15"},"networkPolicies":{"ingress":[],"egress":[]},"owner":{"ownerReferences":[{"kind":"DaemonSet","uid":"f6759874-7801-4d19-92af-ec2982c2d58a","name":"sdn"}],"rootOwner":{"kind":"DaemonSet","uid":"f6759874-7801-4d19-92af-ec2982c2d58a","name":"sdn"}},"tags":[{"key":"app","value":"sdn"},{"key":"component","value":"network"},{"key":"controller-revision-hash","value":"7f78bf6976"},{"key":"openshift.io/component","value":"network"},{"key":"pod-template-generation","value":"2"},{"key":"type","value":"infra"}],"namespace":"openshift-sdn","annotations":[],"labels":[{"key":"app","value":"sdn"},{"key":"component","value":"network"},{"key":"controller-revision-hash","value":"7f78bf6976"},{"key":"openshift.io/component","value":"network"},{"key":"pod-template-generation","value":"2"},{"key":"type","value":"infra"}],"creationTime":1671596978,"id":"3aa450bf-187f-4077-9fc8-aa9ee3ac617d","type":"KubernetesPod","name":"sdn-x2hlv","dome9Id":"11|5af13ab5-72ed-43b6-9544-33c9236d62f0|Pod|3aa450bf-187f-4077-9fc8-aa9ee3ac617d","accountNumber":"5af13ab5-72ed-43b6-9544-33c9236d62f0","assetLabels":null,"region":"Global","externalFindings":null},"remediationActions":[],"action":"Detect","additionalFields":[]}